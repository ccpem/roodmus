"""Integration tests for the simulation utilities.

Delft University of Technology (TU Delft) hereby disclaims
all copyright interest in the program “Roodmus” written by
the Author(s).
Copyright (C) 2023  Joel Greer(UKRI), Tom Burnley (UKRI),
Maarten Joosten (TU Delft), Arjen Jakobi (TU Delft)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.

"""

import unittest
import os
import shutil
import tempfile

import filecmp
import difflib

import yaml
import numpy as np
import mrcfile

from tests.integration import fixtures


def remove_ts_text_file(filename: str) -> str:
    """Some decisions have been made which add date of generation to
    pdb files created via mdtraj and to mtf files created by parakeet.
    These mess up filecmp against a fixed date reference file.
    These dates and other superfluous info are add into first line of
    the text files.
    Therefore, this function creates temporary files which are 1 line
    shorter (removes the first line)

    Args:
        file (str): file

    Returns:
        str: Path of saved file with first line removed
    """
    # get the dirname
    which_dir = os.path.dirname(filename)

    # get the filename
    which_file = os.path.basename(filename)

    # make the new_filename
    file_name_parts = which_file.split(".")
    saved_file = "".join(file_name_parts[:-1])
    saved_file = saved_file + "_removed_line" + "." + file_name_parts[-1]
    saved_file = os.path.join(which_dir, saved_file)

    # load text file into memory and remove first line
    with open(filename, "r") as infile:
        data = infile.read().splitlines(True)

    # save file after removing first line
    with open(saved_file, "w") as outfile:
        outfile.writelines(data[1:])
    print("Saved {} from {}".format(saved_file, filename))

    return saved_file


class IntegrationTest(unittest.TestCase):
    def setUp(self) -> None:
        self.test_data = os.path.dirname(fixtures.__file__)
        self.test_dir = tempfile.mkdtemp()

        # Change to test directory
        self._orig_dir = os.getcwd()
        os.chdir(self.test_dir)

        # set the path to find parakeet
        # see if there is a functioning copy of parakeet
        self.oldpath = os.environ["PATH"]
        return super().setUp()

    def tearDown(self) -> None:
        os.chdir(self._orig_dir)
        if os.path.exists(self.test_dir):
            shutil.rmtree(self.test_dir)
        os.environ["PATH"] = self.oldpath
        return super().tearDown()

    def test_run_parakeet(self) -> None:
        """Test that the correct files are generated by run_parakeet.
        Note that due the implementation of random positions being left
        to Parakeet internally, the checks to be performed are:
          - whether yaml files can be loaded in as non-empty dicts via pyyaml
          without error
          - whether the mrcfiles data have the correct dimensions after
          loading them using mrcfile
        """

        # set up the args to pass to roodmus run_parakeet
        # create dir for pdbs files and move them in there
        pdb_dir = os.path.join(self.test_dir, "conformations")
        os.makedirs(pdb_dir)

        frames = os.listdir(self.test_data)
        frames = [frame for frame in frames if frame.endswith(".pdb")]
        frames = [
            frame for frame in frames if frame.startswith("conformation_")
        ]
        for frame in frames:
            shutil.copy(os.path.join(self.test_data, frame), pdb_dir)

        n_images = 1
        n_molecules = 10
        mrc_dir = os.path.join(self.test_dir, "Micrographs")
        electrons_per_angstrom = 45.0
        energy = 300.0
        nx = 4000
        ny = 4000
        pixel_size = 1.0
        c_10 = -20000.0
        c_10_stddev = 5000.0
        c_c = 2.7
        box_x = 4000.0
        box_y = 4000.0
        box_z = 500.0
        centre_x = 2000.0
        centre_y = 2000.0
        centre_z = 250.0
        sample_type = "cuboid"
        cuboid_length_x = 4000.0
        cuboid_length_y = 4000.0
        cuboid_length_z = 500.0
        simulation_margin = 0
        simulation_padding = 1

        # run the run_parakeet utility
        system_cmd = (
            "roodmus run_parakeet"
            + " --dqe"
            + " --fast_ice"
            + " --pdb_dir {}".format(pdb_dir)
            + " --mrc_dir {}".format(mrc_dir)
            + " --n_images {}".format(n_images)
            + " --n_molecules {}".format(n_molecules)
            + " --electrons_per_angstrom {}".format(electrons_per_angstrom)
            + " --energy {}".format(energy)
            + " --nx {}".format(nx)
            + " --ny {}".format(ny)
            + " --pixel_size {}".format(pixel_size)
            + " --c_10 {}".format(c_10)
            + " --c_10_stddev {}".format(c_10_stddev)
            + " --c_c {}".format(c_c)
            + " --box_x {}".format(box_x)
            + " --box_y {}".format(box_y)
            + " --box_z {}".format(box_z)
            + " --centre_x {}".format(centre_x)
            + " --centre_y {}".format(centre_y)
            + " --centre_z {}".format(centre_z)
            + " --type {}".format(sample_type)
            + " --cuboid_length_x {}".format(cuboid_length_x)
            + " --cuboid_length_y {}".format(cuboid_length_y)
            + " --cuboid_length_z {}".format(cuboid_length_z)
            + " --simulation_margin {}".format(simulation_margin)
            + " --simulation_padding {}".format(simulation_padding)
        )
        os.system(system_cmd)

        # find the outputs
        output_files = os.listdir(mrc_dir)
        output_files = [
            output_file
            for output_file in output_files
            if not os.path.isdir(output_file)
        ]
        output_files = [
            os.path.join(mrc_dir, output_file) for output_file in output_files
        ]
        print("Outputs from {} are:\n{}".format(mrc_dir, os.listdir(mrc_dir)))
        output_mtf_file: str = os.listdir(os.path.join(mrc_dir, "relion"))[0]
        output_mtf_file = os.path.join(
            os.path.join(mrc_dir, "relion"), output_mtf_file
        )

        # ensure the all expected output files exist
        assert (
            os.path.join(mrc_dir, "000000.mrc") in output_files
        ), "000000.mrc not found in {}".format(mrc_dir)
        assert (
            os.path.join(mrc_dir, "000000.yaml") in output_files
        ), "000000.yaml not found in {}".format(mrc_dir)
        assert (
            os.path.join(mrc_dir, os.path.join("relion", "mtf_300kV.star"))
            == output_mtf_file
        ), "mtf_300kV.star not found in {}".format(
            os.path.join(mrc_dir, "relion")
        )

        # load up reference mtf file
        # load the new mtf file and check it is identical to the reference
        ref_file = os.path.join(self.test_data, "mtf_300kV.star")
        with open(ref_file) as ref:
            ref_text = ref.readlines()

        with open(output_mtf_file) as new:
            new_text = new.readlines()

        # not worried about removing ts as this won't cause
        # a test failure until filecmp
        for line in difflib.unified_diff(
            ref_text,
            new_text,
            fromfile=ref_file,
            tofile=output_mtf_file,
            lineterm="",
        ):
            print(line)

        # removed ts line and
        # ensure they are the same
        ref_file_no_ts = remove_ts_text_file(ref_file)
        output_mtf_file_no_ts = remove_ts_text_file(output_mtf_file)
        assert filecmp.cmp(ref_file_no_ts, output_mtf_file_no_ts)
        os.remove(ref_file_no_ts)
        os.remove(output_mtf_file_no_ts)

        # load the yaml files into pyyaml-created dicts and check that
        # at least the fields set above have the values expected
        for yaml_name in [
            yaml_file
            for yaml_file in output_files
            if yaml_file.endswith(".yaml")
        ]:
            with open(yaml_name) as yaml_stream:
                yaml_data = yaml.safe_load(yaml_stream)
                assert int(yaml_data["microscope"]["detector"]["dqe"]) == 1
                assert int(yaml_data["simulation"]["ice"]) == 1
                assert np.isclose(
                    yaml_data["microscope"]["beam"]["electrons_per_angstrom"],
                    45.0,
                    atol=1e-08,
                    equal_nan=False,
                )
                assert np.isclose(
                    yaml_data["microscope"]["beam"]["energy"],
                    300.0,
                    atol=1e-08,
                    equal_nan=False,
                )
                assert yaml_data["microscope"]["detector"]["nx"] == 4000
                assert yaml_data["microscope"]["detector"]["ny"] == 4000
                assert np.isclose(
                    yaml_data["microscope"]["detector"]["pixel_size"],
                    1.0,
                    atol=1e-08,
                    equal_nan=False,
                )
                assert np.isclose(
                    yaml_data["microscope"]["lens"]["c_c"],
                    2.7,
                    atol=1e-08,
                    equal_nan=False,
                )
                assert np.isclose(
                    yaml_data["sample"]["box"][0],
                    4000.0,
                    atol=1e-08,
                    equal_nan=False,
                )
                assert np.isclose(
                    yaml_data["sample"]["box"][1],
                    4000.0,
                    atol=1e-08,
                    equal_nan=False,
                )
                assert np.isclose(
                    yaml_data["sample"]["box"][2],
                    500.0,
                    atol=1e-08,
                    equal_nan=False,
                )
                assert np.isclose(
                    yaml_data["sample"]["centre"][0],
                    2000.0,
                    atol=1e-08,
                    equal_nan=False,
                )
                assert np.isclose(
                    yaml_data["sample"]["centre"][1],
                    2000.0,
                    atol=1e-08,
                    equal_nan=False,
                )
                assert np.isclose(
                    yaml_data["sample"]["centre"][2],
                    250.0,
                    atol=1e-08,
                    equal_nan=False,
                )
                assert yaml_data["sample"]["shape"]["type"] == "cuboid"
                assert np.isclose(
                    yaml_data["sample"]["shape"]["cuboid"]["length_x"],
                    4000.0,
                    atol=1e-08,
                    equal_nan=False,
                )
                assert np.isclose(
                    yaml_data["sample"]["shape"]["cuboid"]["length_y"],
                    4000.0,
                    atol=1e-08,
                    equal_nan=False,
                )
                assert np.isclose(
                    yaml_data["sample"]["shape"]["cuboid"]["length_z"],
                    500.0,
                    atol=1e-08,
                    equal_nan=False,
                )
                assert yaml_data["simulation"]["margin"] == 0
                assert yaml_data["simulation"]["padding"] == 1

                # check there are the correct number of particles in
                # the yaml files
                for image in yaml_data["sample"]["molecules"]["local"]:
                    self.assertEqual(len(image["instances"]), 5)

        # load the mrcfiles and check that each has the dimensions specified
        for mrc in [
            mrc_file for mrc_file in output_files if mrc_file.endswith(".mrc")
        ]:
            with mrcfile.open(mrc) as my_mrc:
                print("Image shape is: {}".format(my_mrc.data.shape))
                assert my_mrc.data.shape == (
                    1,
                    4000,
                    4000,
                ), "Shape not 1x4000x4000 as expected.\nIs: {}".format(
                    my_mrc.data.shape
                )

    # maybe should add filecmp for run_parakeet_output/ files????

    def test_write_starfile(self) -> None:
        """
        Test that a correct .star file is generated
        based on the input .csv dataframe file
        """

        # set up the args to pass to roodmus write_starfile
        csv_file = os.path.join(
            self.test_data,
            "analysis_test_outputs",
            "picking_star",
            "label_truth",
            "df_truth.csv",
        )
        output_dir = os.path.join(self.test_dir, "star_files")
        os.makedirs(output_dir)

        # run the write_starfile utility
        system_cmd = (
            "roodmus write_starfile"
            + " --input_csv {}".format(csv_file)
            + " --type coordinate_star"
            + " --output_dir {}".format(output_dir)
            + " --ugraph_dir {}".format(output_dir)
            + " --pixel_size 1.0"
        )
        os.system(system_cmd)

        # check that the groundtruth.star file has been generated
        assert os.path.exists(
            os.path.join(output_dir, "groundtruth.star")
        ), "groundtruth.star not found in {}".format(output_dir)

        # check that there are individual particle starfiles
        # in the micrographs directory
        assert os.path.exists(
            os.path.join(output_dir, "micrographs")
        ), "micrographs directory not found in {}".format(output_dir)
        assert (
            len(os.listdir(os.path.join(output_dir, "micrographs"))) > 0
        ), "No files found in micrographs directory in {}".format(output_dir)

        # a comparison with the contents of the groundtruth.star file
        # is currently not possible, since the output directory is
        # also used as the name for where to find the micrographs,
        # and since this directory is created by the utility, the
        # paths in the .star file will not match the reference file
